<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>SmartLMS - Auth</title>
  <style>
    body { font-family: Arial, sans-serif; background: #f9f9f9; margin: 0; display: flex; justify-content: center; align-items: center; height: 100vh; }
    .container { width: min(420px, 92vw); background: #fff; padding: 25px; border-radius: 10px; box-shadow: 0 2px 10px rgba(0,0,0,0.2); display: none; }
    h2 { text-align: center; }
    input, button { width: 100%; padding: 10px; margin: 8px 0; border-radius: 5px; border: 1px solid #ccc; }
    button { background: purple; color: #fff; font-weight: bold; cursor: pointer; }
    button:hover { background: darkviolet; }
    .note { text-align: center; font-size: 14px; }
    .error { color: red; font-size: 13px; margin-top: -5px; min-height: 18px; }
    .role-btn { display: block; padding: 12px; margin: 10px 0; background: purple; color: white; text-align: center; border-radius: 5px; text-decoration: none; font-weight: bold; }
    .role-btn:hover { background: darkviolet; }
    @media (max-width: 480px) {
      body { align-items: flex-start; padding-top: 5vh; height: auto; }
      .container { padding: 18px; border-radius: 8px; }
      input, button { padding: 12px; }
    }
  </style>
</head>
<body>
  <!-- Landing -->
  <div id="landing" class="container" style="display:block;">
    <div id="maintBanner" style="display:none;background:#fff4c2;border:1px solid #e6e9ee;border-radius:6px;padding:6px 10px;margin-bottom:8px;text-align:center;font-size:13px"></div>
    <h2>Select Role</h2>
    <a href="#" class="role-btn" onclick="showSignup('student')">Student</a>
    <a href="#" class="role-btn" onclick="showSignup('teacher')">Teacher</a>
    <a href="#" class="role-btn" onclick="showSignup('admin')">Admin</a>
    <p class="note"><a href="#" onclick="showLogin()">Already have an account? Sign in</a></p>
  </div>

  <!-- Signup -->
  <div id="signup" class="container">
    <div id="maintBannerSignup" style="display:none;background:#fff4c2;border:1px solid #e6e9ee;border-radius:6px;padding:6px 10px;margin-bottom:8px;text-align:center;font-size:13px"></div>
    <h2 id="signup-title">Sign Up</h2>
    <form id="signupForm" novalidate>
      <input type="text" id="fullName" placeholder="Full Name" required>
      <input type="email" id="email" placeholder="Email" required>
      <input type="tel" id="phone" placeholder="Phone (optional)">
      <input type="password" id="password" placeholder="Password" required>
      <input type="password" id="confirmPassword" placeholder="Confirm Password" required>
      <input type="hidden" id="role">
      <button type="submit">Create Account</button>
      <p class="note"><a href="#" onclick="showLogin()">Already have an account? Sign in</a></p>
    </form>
    <p class="error" id="signupError"></p>
  </div>

  <!-- Login -->
  <div id="login" class="container">
    <div id="maintBannerLogin" style="display:none;background:#fff4c2;border:1px solid #e6e9ee;border-radius:6px;padding:6px 10px;margin-bottom:8px;text-align:center;font-size:13px"></div>
    <h2>Login</h2>
    <form id="loginForm" novalidate>
      <input type="email" id="loginEmail" placeholder="Email" required>
      <p class="error" id="loginEmailError"></p>
      <input type="password" id="loginPassword" placeholder="Password" required>
      <p class="error" id="loginPasswordError"></p>
      <button type="submit">Login</button>
    </form>
    <p class="note"><a href="#" onclick="showReset()">Forgot Password?</a></p>
    <p class="note"><a href="#" onclick="showSignup()">Create account</a></p>
  </div>

  <!-- Reset Request -->
  <div id="reset" class="container">
    <div id="maintBannerReset" style="display:none;background:#fff4c2;border:1px solid #e6e9ee;border-radius:6px;padding:6px 10px;margin-bottom:8px;text-align:center;font-size:13px"></div>
    <h2>Reset Password</h2>
    <form id="resetForm" novalidate>
      <input type="email" id="resetEmail" placeholder="Enter your email" required>
      <button type="submit">Request Reset</button>
    </form>
    <p class="note"><a href="#" onclick="showLogin()">Back to login</a></p>
    <p class="error" id="resetError"></p>
  </div>

  <!-- Set New Password (after temp login) -->
  <div id="newPassword" class="container">
    <h2>Set New Password</h2>
    <form id="newPasswordForm" novalidate>
      <input type="password" id="newPass" placeholder="New Password" required>
      <input type="password" id="confirmNewPass" placeholder="Confirm New Password" required>
      <button type="submit">Update Password</button>
    </form>
    <p class="error" id="newPasswordError"></p>
  </div>

  <script>
    // ---- Utilities ----
    const supportsIndexedDB = typeof indexedDB !== 'undefined';
    const DB_NAME = 'smartlms-auth';
    const DB_VERSION = 3; // v3 adds per-tab sessions store

    function normalizeEmail(email) {
      return (email || '').trim().toLowerCase();
    }

    // Maintenance helpers (shared)
    async function getMaintenance() {
      if (!supportsIndexedDB) {
        try { return JSON.parse(localStorage.getItem('maintenance')||'{}')||{}; } catch(_) { return {}; }
      }
      const db = await openDB();
      return new Promise((resolve)=>{
        const tx = db.transaction('meta','readonly');
        const st = tx.objectStore('meta');
        const r = st.get('maintenance');
        r.onsuccess = ()=> resolve(r.result? r.result.value : {});
        r.onerror = ()=> resolve({});
      });
    }

    async function setMaintenance(m){
      // Persist maintenance state and broadcast change
      if (!supportsIndexedDB) {
        try { localStorage.setItem('maintenance', JSON.stringify(m||{})); } catch(_) {}
      } else {
        try {
          const db = await openDB();
          await new Promise((resolve) => {
            const tx = db.transaction('meta', 'readwrite');
            tx.objectStore('meta').put({ key: 'maintenance', value: m||{} });
            tx.oncomplete = () => resolve();
            tx.onerror = () => resolve();
          });
        } catch(_) {}
      }
      // Best-effort broadcast to other tabs and listeners
      try {
        const bc = new BroadcastChannel('smartlms_maint');
        bc.postMessage({ type: (m && m.enabled) ? 'maintenance_active' : 'maintenance_disabled', payload: { updatedAt: Date.now() } });
        bc.close();
      } catch(_) {}
      try { localStorage.setItem('smartlms_maint_broadcast', JSON.stringify({ type: (m && m.enabled) ? 'maintenance_active' : 'maintenance_disabled', payload: { updatedAt: Date.now() } })); } catch(_) {}
    }
    function isActiveMaintenance(m){
      const now = Date.now();
      if(m.enabled && m.manualUntil && now < m.manualUntil) return true;
      const schedules = Array.isArray(m.schedules)? m.schedules:[];
      return schedules.some(s => now>=s.startAt && now<=s.endAt);
    }
    function getUpcomingMaintenance(m){
      const now = Date.now();
      const schedules = (Array.isArray(m.schedules)? m.schedules:[]).filter(s=> s.startAt>now).sort((a,b)=>a.startAt-b.startAt);
      return schedules[0] || null;
    }

    function getActiveMaintenanceEnd(m){
      const now = Date.now();
      if(m && m.manualUntil && now < m.manualUntil) return m.manualUntil;
      const s = (Array.isArray(m.schedules)? m.schedules:[]).find(s => now>=s.startAt && now<=s.endAt);
      return s ? s.endAt : null;
    }

    // Listen for maintenance broadcasts for tabs without IndexedDB session control
    try {
      const bc = new BroadcastChannel('smartlms_maint');
      bc.onmessage = async (ev)=>{ const msg = ev.data||{}; if(msg.type==='maintenance_active'){ await updateMaintBanners(); } if(msg.type==='maintenance_disabled'){ await updateMaintBanners(); } };
    } catch(_) {}
    window.addEventListener('storage', async (e)=>{
      if(e.key==='smartlms_maint_broadcast'){
        try{ const msg = JSON.parse(e.newValue||'{}'); if(msg && msg.type==='force_logout_user'){ const me = await getCurrentUser(); if(me && (me.email||'').toLowerCase() === ((msg.payload&&msg.payload.email||'').toLowerCase())){ await clearCurrentUser(); return; } } }catch(_){ }
        await updateMaintBanners();
      }
    });

    function mountMaintBanners(){
      return {
        landing: document.getElementById('maintBanner'),
        signup: document.getElementById('maintBannerSignup'),
        login: document.getElementById('maintBannerLogin'),
        reset: document.getElementById('maintBannerReset'),
      };
    }

    async function updateMaintBanners(){
      const m = await getMaintenance();
      const b = mountMaintBanners();
      const banners = [b.landing,b.signup,b.login,b.reset];
      const showText = (el, text)=>{ if(!el) return; if(text){ el.style.display='block'; el.textContent=text; } else { el.style.display='none'; el.textContent=''; } };
      if(isActiveMaintenance(m)){
        const until = m.manualUntil || (m.schedules||[]).find(s=> Date.now()>=s.startAt && Date.now()<=s.endAt)?.endAt;
        const remain = Math.max(0, (until||Date.now()) - Date.now());
        const h = Math.floor(remain/3600000);
        const mm = Math.floor((remain%3600000)/60000);
        const ss = Math.floor((remain%60000)/1000);
        const msg = `System maintenance ACTIVE â€” restores in ${h}h ${mm}m ${ss}s (until ${new Date(until||Date.now()).toLocaleString()})`;
        banners.forEach(el=> showText(el, msg));
      } else {
        const up = getUpcomingMaintenance(m);
        if(up){
          const remain = Math.max(0, up.startAt - Date.now());
          const h = Math.floor(remain/3600000);
          const mm = Math.floor((remain%3600000)/60000);
          const ss = Math.floor((remain%60000)/1000);
          const msg = `Upcoming system maintenance â€” starts in ${h}h ${mm}m ${ss}s (at ${new Date(up.startAt).toLocaleString()})`;
          banners.forEach(el=> showText(el, msg));
        } else {
          banners.forEach(el=> showText(el, null));
        }
      }
    }

    function isAccountLocked(user) {
      return !!(user && user.lockedUntil && Date.now() < user.lockedUntil);
    }

    function isStrongPassword(pass) {
      if (!pass || pass.length < 8) return false;
      const hasLetter = /[A-Za-z]/.test(pass);
      const hasNumber = /\d/.test(pass);
      return hasLetter && hasNumber;
    }

    // ---- IndexedDB helpers ----
    function openDB() {
      return new Promise((resolve, reject) => {
        const req = indexedDB.open(DB_NAME, DB_VERSION);
        req.onupgradeneeded = () => {
          const db = req.result;
          if (!db.objectStoreNames.contains('users')) {
            const users = db.createObjectStore('users', { keyPath: 'email' });
            users.createIndex('email', 'email', { unique: true });
          }
          if (!db.objectStoreNames.contains('meta')) {
            db.createObjectStore('meta', { keyPath: 'key' });
          }
          if (!db.objectStoreNames.contains('sessions')) {
            db.createObjectStore('sessions', { keyPath: 'id' });
          }
        };
        req.onsuccess = () => resolve(req.result);
        req.onerror = () => reject(req.error);
      });
    }

    async function idbGetAllUsers() {
      const db = await openDB();
      return new Promise((resolve, reject) => {
        const tx = db.transaction('users', 'readonly');
        const store = tx.objectStore('users');
        const r = store.getAll();
        r.onsuccess = () => resolve(r.result || []);
        r.onerror = () => reject(r.error);
      });
    }

    async function idbReplaceAllUsers(users) {
      const db = await openDB();
      return new Promise((resolve, reject) => {
        const tx = db.transaction('users', 'readwrite');
        const store = tx.objectStore('users');
        const clearReq = store.clear();
        clearReq.onerror = () => reject(clearReq.error);
        clearReq.onsuccess = () => {
          (users || []).forEach(u => { try { store.put(u); } catch (_) {} });
        };
        tx.oncomplete = () => resolve();
        tx.onerror = () => reject(tx.error);
        tx.onabort = () => reject(tx.error);
      });
    }

    async function idbPutUser(user) {
      const db = await openDB();
      return new Promise((resolve, reject) => {
        const tx = db.transaction('users', 'readwrite');
        const store = tx.objectStore('users');
        store.put(user);
        tx.oncomplete = () => resolve();
        tx.onerror = () => reject(tx.error);
      });
    }

    // v3 session helpers
    function getSessionId() {
      let sid = sessionStorage.getItem('sessionId');
      if (!sid) {
        sid = 's_' + Math.random().toString(36).slice(2) + Date.now().toString(36);
        sessionStorage.setItem('sessionId', sid);
      }
      return sid;
    }

    async function idbGetSessionUser(sessionId) {
      const db = await openDB();
      return new Promise((resolve) => {
        const tx = db.transaction('sessions', 'readonly');
        const store = tx.objectStore('sessions');
        const r = store.get(sessionId);
        r.onsuccess = () => resolve(r.result ? r.result.user : null);
        r.onerror = () => resolve(null);
      });
    }

    async function idbSetSessionUser(sessionId, user) {
      const db = await openDB();
      return new Promise((resolve) => {
        const tx = db.transaction('sessions', 'readwrite');
        const store = tx.objectStore('sessions');
        store.put({ id: sessionId, user });
        tx.oncomplete = () => resolve();
        tx.onerror = () => resolve();
      });
    }

    async function idbClearSessionUser(sessionId) {
      const db = await openDB();
      return new Promise((resolve) => {
        const tx = db.transaction('sessions', 'readwrite');
        tx.objectStore('sessions').delete(sessionId);
        tx.oncomplete = () => resolve();
        tx.onerror = () => resolve();
      });
    }

    async function migrateLocalStorageToIDBIfNeeded() {
      if (!supportsIndexedDB) return;
      try {
        const existing = await idbGetAllUsers();
        if (existing && existing.length > 0) return;
        const lsUsersRaw = localStorage.getItem('users');
        if (lsUsersRaw) {
          try {
            const lsUsers = JSON.parse(lsUsersRaw) || [];
            if (Array.isArray(lsUsers) && lsUsers.length) {
              await idbReplaceAllUsers(lsUsers);
            }
          } catch (_) {}
        }
        const lsCurrentRaw = localStorage.getItem('currentUser');
        if (lsCurrentRaw) {
          try {
            const cu = JSON.parse(lsCurrentRaw);
            await idbSetCurrentUser(cu);
          } catch (_) {}
        }
        // Clean up LS after migration to avoid divergence
        localStorage.removeItem('users');
        localStorage.removeItem('currentUser');
      } catch (_) {
        // Ignore migration errors; fallback continues to work
      }
    }

    // ---- Storage API (IndexedDB with localStorage fallback) ----
    async function getUsers() {
      if (supportsIndexedDB) {
        try { return await idbGetAllUsers(); } catch (_) {}
      }
      return JSON.parse(localStorage.getItem('users')) || [];
    }

    async function saveUsers(users) {
      if (supportsIndexedDB) {
        try { await idbReplaceAllUsers(users); return; } catch (_) {}
      }
      localStorage.setItem('users', JSON.stringify(users || []));
    }

    // Per-tab session API
    async function setCurrentUser(user) {
      const sid = getSessionId();
      if (supportsIndexedDB) {
        try { await idbSetSessionUser(sid, user); return; } catch (_) {}
      }
      sessionStorage.setItem('currentUser', JSON.stringify(user));
    }

    async function getCurrentUser() {
      const sid = getSessionId();
      if (supportsIndexedDB) {
        try { return await idbGetSessionUser(sid); } catch (_) {}
      }
      const raw = sessionStorage.getItem('currentUser');
      return raw ? JSON.parse(raw) : null;
    }

    async function clearCurrentUser() {
      const sid = getSessionId();
      if (supportsIndexedDB) {
        try { await idbClearSessionUser(sid); } catch (_) {}
      }
      sessionStorage.removeItem('currentUser');
    }

    // ---- Section Switching ----
    function showSection(id) {
      document.querySelectorAll('.container').forEach(c => c.style.display = 'none');
      const el = document.getElementById(id);
      if (el) el.style.display = 'block';
    }
    function showSignup(role) {
      document.getElementById('signup-title').innerText = role ? `Sign Up as ${role}` : 'Sign Up';
      document.getElementById('role').value = role || 'student';
      showSection('signup');
    }
    function showLogin() { showSection('login'); }
    function showReset() { showSection('reset'); }
    function showNewPassword() { showSection('newPassword'); }

    // ---- Signup ----
    document.getElementById('signupForm').addEventListener('submit', async (e) => {
      e.preventDefault();
      const m = await getMaintenance();
      if(isActiveMaintenance(m)){
        const untilTs = getActiveMaintenanceEnd(m);
        const untilStr = untilTs ? new Date(untilTs).toLocaleString() : 'the scheduled end time';
        alert(`System is currently undergoing maintenance. Signups are disabled until ${untilStr}.`);
        return;
      }
      const upcoming = getUpcomingMaintenance(m);
      if(upcoming){ alert(`Upcoming system maintenance: ${new Date(upcoming.startAt).toLocaleString()}`); }
      const fullName = (document.getElementById('fullName').value || '').trim();
      const email = normalizeEmail(document.getElementById('email').value);
      const phone = (document.getElementById('phone').value || '').trim();
      const password = document.getElementById('password').value;
      const confirm = document.getElementById('confirmPassword').value;
      const role = (document.getElementById('role').value || 'student');

      const errorEl = document.getElementById('signupError');
      errorEl.innerText = '';

      let users = await getUsers();
      const existing = users.find(u => u.email === email);
      if (existing) {
        if (existing.resetRequest && (existing.resetRequest.status === 'pending' || existing.resetRequest.status === 'approved')) {
          errorEl.innerText = 'This account has an active password reset request. You cannot sign up again.';
          return;
        }
        errorEl.innerText = 'Account with this email already exists.';
        return;
      }
      if (password !== confirm) {
        errorEl.innerText = 'Passwords do not match.';
        return;
      }
      if (!isStrongPassword(password)) {
        errorEl.innerText = 'Password must be at least 8 chars with letters and numbers.';
        return;
      }

      const user = {
        fullName, email, phone, password, role,
        createdAt: Date.now(), failedAttempts: 0, lockedUntil: null,
        lockouts: 0, flagged: false, resetRequest: null, active: true, notifications: []
      };
      users.push(user);
      await saveUsers(users);
      await setCurrentUser(user);

      alert(`Welcome ${fullName}! Your ${role} account has been created.`);
      redirectByRole(role);
    });

    // ---- Login ----
    document.getElementById('loginForm').addEventListener('submit', async (e) => {
      e.preventDefault();
      const email = normalizeEmail(document.getElementById('loginEmail').value);
      const m = await getMaintenance();
      if(isActiveMaintenance(m)){
        let allow = false;
        try {
          const users = await getUsers();
          const u = users.find(u => u.email === email);
          allow = !!(u && u.role === 'admin');
        } catch(_){ allow = false; }
        if(!allow){
          const untilTs = getActiveMaintenanceEnd(m);
          const untilStr = untilTs ? new Date(untilTs).toLocaleString() : 'the scheduled end time';
          alert(`System is currently undergoing maintenance. Only admin login allowed until ${untilStr}.`);
          return;
        }
      }
      const upcoming = getUpcomingMaintenance(m);
      if(upcoming){ alert(`Upcoming system maintenance: ${new Date(upcoming.startAt).toLocaleString()}`); }
      
      const password = document.getElementById('loginPassword').value;
      let users = await getUsers();
      let user = users.find(u => u.email === email);

      document.getElementById('loginEmailError').innerText = '';
      document.getElementById('loginPasswordError').innerText = '';

      if (!user) {
        document.getElementById('loginEmailError').innerText = 'No account found with this email';
        return;
      }
      if (!user.active) {
        document.getElementById('loginEmailError').innerText = 'Your account has been deactivated by an administrator.';
        return;
      }

      // Handle expired reset requests (approved or pending beyond expiry)
      if (user.resetRequest && user.resetRequest.expiresAt && Date.now() > user.resetRequest.expiresAt) {
        user.resetRequest = null;
        users = users.map(u => u.email === user.email ? user : u);
        await saveUsers(users);
      }

      if (user.resetRequest) {
        if (user.resetRequest.status === 'pending') {
          document.getElementById('loginPasswordError').innerText = 'Password reset request pending admin review.';
          return;
        }
        if (user.resetRequest.status === 'approved') {
          // Only allow login if using temp password and not expired
          if (user.resetRequest.expiresAt && Date.now() > user.resetRequest.expiresAt) {
            user.resetRequest = null;
            users = users.map(u => u.email === user.email ? user : u);
            await saveUsers(users);
            document.getElementById('loginPasswordError').innerText = 'Temporary password expired. Please request a new reset.';
            return;
          }
          if (password === user.resetRequest.tempPassword) {
            await setCurrentUser(user);
            showNewPassword();
            return;
          } else {
            document.getElementById('loginPasswordError').innerText = `Your reset request is approved. Use this temporary password: ${user.resetRequest.tempPassword}`;
            return;
          }
        }
        if (user.resetRequest.status === 'denied') {
          document.getElementById('loginPasswordError').innerText = 'Your reset request was denied. You may request a new reset.';
          return;
        }
      }

      if (isAccountLocked(user)) {
        const mins = Math.ceil((user.lockedUntil - Date.now()) / 60000);
        document.getElementById('loginPasswordError').innerText = `Account is locked. Try again in ${mins} minutes`;
        return;
      }

      if (user.password !== password) {
        user.failedAttempts++;
        if (user.failedAttempts >= 5) {
          user.lockedUntil = Date.now() + 30 * 60000;
          user.failedAttempts = 0;
          user.lockouts++;
          if (user.lockouts >= 3) user.flagged = true;
          document.getElementById('loginPasswordError').innerText = 'Too many failed attempts. Account locked for 30 minutes';
        } else {
          const remain = 5 - user.failedAttempts;
          document.getElementById('loginPasswordError').innerText = `Invalid password. ${remain} attempts remaining`;
        }
        users = users.map(u => u.email === user.email ? user : u);
        await saveUsers(users);
        return;
      }

      // normal login
      user.failedAttempts = 0;
      user.lockedUntil = null;
      users = users.map(u => u.email === user.email ? user : u);
      await saveUsers(users);
      await setCurrentUser(user);

      alert(`Welcome back ${user.fullName}!`);
      redirectByRole(user.role);
    });

    // ---- Reset ----
    document.getElementById('resetForm').addEventListener('submit', async (e) => {
      e.preventDefault();
      const email = normalizeEmail(document.getElementById('resetEmail').value);
      const m = await getMaintenance();
      if(isActiveMaintenance(m)){
        try {
          const users = await getUsers();
          const u = users.find(u => u.email === email);
          if(!(u && u.role === 'admin')){
            const untilTs = getActiveMaintenanceEnd(m);
            const untilStr = untilTs ? new Date(untilTs).toLocaleString() : 'the scheduled end time';
            document.getElementById('resetError').innerText = `System is currently undergoing maintenance. No reset allowed until ${untilStr}.`;
            return;
          }
        } catch(_){
          const untilTs = getActiveMaintenanceEnd(m);
          const untilStr = untilTs ? new Date(untilTs).toLocaleString() : 'the scheduled end time';
          document.getElementById('resetError').innerText = `System is currently undergoing maintenance. No reset allowed until ${untilStr}.`;
          return;
        }
      }
      const upcoming = getUpcomingMaintenance(m);
      if(upcoming){ document.getElementById('resetError').innerText = `Upcoming system maintenance: ${new Date(upcoming.startAt).toLocaleString()}`; }
      
      let users = await getUsers();
      let user = users.find(u => u.email === email);

      const err = document.getElementById('resetError');
      err.innerText = '';

      if (!user) {
        err.innerText = 'No account found with this email';
        return;
      }
      if (!user.active) {
        err.innerText = 'Your account has been deactivated.';
        return;
      }
      if (user.flagged) {
        err.innerText = 'Your account is flagged. Please contact admin for support.';
        return;
      }
      if (isAccountLocked(user)) {
        err.innerText = 'Your account is locked due to failed attempts. Try again later.';
        return;
      }

      // Expire old reset automatically
      if (user.resetRequest && user.resetRequest.expiresAt && Date.now() > user.resetRequest.expiresAt) {
        user.resetRequest = null;
      }

      if (user.resetRequest) {
        if (user.resetRequest.status === 'pending') {
          err.innerText = 'Reset request already pending review.';
          return;
        }
        if (user.resetRequest.status === 'approved') {
          err.innerText = 'Reset already approved. Please use your temporary password to login.';
          return;
        }
      }

      const tempPassword = Math.random().toString(36).slice(-8);
      user.resetRequest = {
        status: 'pending',
        tempPassword,
        createdAt: Date.now(),
        expiresAt: Date.now() + 72 * 3600 * 1000,
        denialReason: null
      };
      user.notifications = user.notifications || [];
      user.notifications.push({
        type: 'reset_requested',
        at: Date.now(),
        message: 'Password reset requested and pending admin review.'
      });

      users = users.map(u => u.email === user.email ? user : u);
      await saveUsers(users);

      alert('Password reset request submitted. Admin will review it.');
      showLogin();
    });

    // ---- New Password ----
    document.getElementById('newPasswordForm').addEventListener('submit', async (e) => {
      e.preventDefault();
      let user = await getCurrentUser();
      let users = await getUsers();

      const newPass = document.getElementById('newPass').value;
      const confirm = document.getElementById('confirmNewPass').value;

      const err = document.getElementById('newPasswordError');
      err.innerText = '';

      if (!user) {
        err.innerText = 'Session expired. Please login again with temporary password.';
        showLogin();
        return;
      }

      // Validate reset approval still valid
      const freshUser = users.find(u => u.email === user.email) || user;
      if (!freshUser.resetRequest || freshUser.resetRequest.status !== 'approved') {
        err.innerText = 'No active reset found. Please request a new reset.';
        showReset();
        return;
      }
      if (freshUser.resetRequest.expiresAt && Date.now() > freshUser.resetRequest.expiresAt) {
        freshUser.resetRequest = null;
        users = users.map(u => u.email === freshUser.email ? freshUser : u);
        await saveUsers(users);
        err.innerText = 'Temporary password expired. Please request a new reset.';
        showReset();
        return;
      }

      if (newPass !== confirm) {
        err.innerText = 'Passwords do not match.';
        return;
      }
      if (!isStrongPassword(newPass)) {
        err.innerText = 'Password must be at least 8 chars with letters and numbers.';
        return;
      }

      // update password and clear reset request
      freshUser.password = newPass;
      freshUser.resetRequest = null;
      freshUser.notifications = freshUser.notifications || [];
      freshUser.notifications.push({ type: 'password_updated', at: Date.now(), message: 'Password updated after reset.' });

      users = users.map(u => u.email === freshUser.email ? freshUser : u);
      await saveUsers(users);
      await setCurrentUser(freshUser);

      alert('Password successfully reset. You can now login with your new password.');
      showLogin();
    });

    // ---- Redirect ----
    function redirectByRole(role) {
      if (role === 'student') window.location.href = 'student.html';
      else if (role === 'teacher') window.location.href = 'teacher.html';
      else if (role === 'admin') window.location.href = 'admin.html';
    }

    // ---- Initialize ----
    (async function init() {
      if (supportsIndexedDB) {
        try { await migrateLocalStorageToIDBIfNeeded(); } catch (_) {}
      }
      // show maintenance banners with countdowns
      await updateMaintBanners();
      setInterval(updateMaintBanners, 1000);
      // Legacy global session migration (from v1): if meta.currentUser or LS currentUser exists, attach to this tab session
      try {
        const legacy = localStorage.getItem('currentUser');
        if (legacy) {
          const parsed = JSON.parse(legacy);
          await setCurrentUser(parsed);
          localStorage.removeItem('currentUser');
        }
      } catch (_) {}
      showSection('landing');
    })();
  </script>

  <!-- === Supabase-Sync Module (SmartLMS Landing Page) === -->
  <script src="https://cdn.jsdelivr.net/npm/@supabase/supabase-js@2"></script>
  <script>
  /* ---------- Banner ---------- */
  const banner=document.createElement("div");
  banner.id="syncBanner";
  banner.textContent="ðŸ”„ Sync Status: Initializingâ€¦";
  banner.style.cssText="position:fixed;top:0;left:50%;transform:translateX(-50%);background:#eef4ff;color:#222;padding:6px 16px;border:1px solid #ccd3ff;border-radius:0 0 8px 8px;font-size:14px;font-weight:600;z-index:9999;";
  document.body.prepend(banner);
  function updateBanner(t){banner.textContent=`ðŸ”„ Sync Status: ${t}`;}

  /* ---------- Supabase Init ---------- */
  const SUPABASE_URL="https://eljbrcqgwgrzzjulsjka.supabase.co";
  const SUPABASE_ANON_KEY="YOUR_ANON_KEY_HERE";
  const supa=supabase.createClient(SUPABASE_URL,SUPABASE_ANON_KEY);

  /* ---------- Helpers ---------- */
  function delay(ms){return new Promise(r=>setTimeout(r,ms));}
  async function getLocalUsers(){return await getUsers();}
  async function putLocalUser(u){return await idbPutUser(u);} 
  async function getMaint(){return await getMaintenance();}
  async function setMaint(m){return await setMaintenance(m);} 
  async function getCurrent(){return await getCurrentUser();}
  async function clearCurrent(){return await clearCurrentUser();}

  /* ---------- Sync Users To Cloud ---------- */
  async function syncUsersToCloud(){
   if(!navigator.onLine){updateBanner("Offline â€“ Local Only");return;}
   updateBanner("Online â€“ Uploading Usersâ€¦");
   try{
     const local=await getLocalUsers();
     const {data:remote}=await supa.from("users").select("email,updated_at");
     const map=new Map((remote||[]).map(r=>[r.email,r]));
     for(const u of local){
       if(!u.email)continue;
       const r=map.get(u.email);
       const lt=u.updatedAt||0;
       const rt=r?.updated_at?new Date(r.updated_at).getTime():0;
       if(!r||lt>rt){
         await supa.from("users").upsert({
           full_name:u.fullName,email:u.email,password:u.password,role:u.role,
           active:u.active,flagged:u.flagged,lockouts:u.lockouts,
           failed_attempts:u.failedAttempts,locked_until:u.lockedUntil?new Date(u.lockedUntil).toISOString():null,
           reset_request:u.resetRequest,notifications:u.notifications||[],
           updated_at:new Date(lt||Date.now()).toISOString()
         },{onConflict:"email"});
       }
     }
     updateBanner("Online â€“ Users Synced");
   }catch(e){console.error(e);updateBanner("User Sync Error");}
  }

  /* ---------- Sync From Cloud ---------- */
  async function syncUsersFromCloud(){
   if(!navigator.onLine)return;
   try{
     const {data}=await supa.from("users").select("*");
     const local=await getLocalUsers();
     const map=new Map(local.map(u=>[u.email,u]));
     for(const r of data||[]){
       const l=map.get(r.email);
       const rt=r.updated_at?new Date(r.updated_at).getTime():0;
       const lt=l?.updatedAt||0;
       if(!l||rt>lt){
         await putLocalUser({...l,
           fullName:r.full_name,email:r.email,password:r.password,role:r.role,
           active:r.active,flagged:r.flagged,lockouts:r.lockouts,
           failedAttempts:r.failed_attempts,lockedUntil:r.locked_until?new Date(r.locked_until).getTime():null,
           resetRequest:r.reset_request,notifications:r.notifications||[],
           updatedAt:rt});
       }
     }
     updateBanner("Online â€“ Users Updated");
   }catch(e){console.error(e);}
  }

  /* ---------- Maintenance Enforcement ---------- */
  async function enforceMaintenance(){
   const m=await getMaint();const u=await getCurrent();
   if(m?.enabled){
     const admin=u&&u.role==="admin";
     if(u&&!admin){await clearCurrent();alert("System under maintenance. Youâ€™ve been logged out.");location.href="index.html";return;}
     ["signupForm","loginForm","resetForm"].forEach(id=>{const f=document.getElementById(id);if(f)for(const e of f.elements)e.disabled=!admin;});
   }else{["signupForm","loginForm","resetForm"].forEach(id=>{const f=document.getElementById(id);if(f)for(const e of f.elements)e.disabled=false;});}
  }

  /* ---------- Fetch Maintenance From Cloud ---------- */
  async function fetchMaintenance(){
   if(!navigator.onLine)return;
   const {data}=await supa.from("maintenance").select("*").limit(1);
   if(data&&data.length){
     const r=data[0];
     await setMaint({enabled:r.active,message:r.message,manualUntil:r.end_time?new Date(r.end_time).getTime():null,updatedAt:r.updated_at?new Date(r.updated_at).getTime():Date.now()});
     await enforceMaintenance();
   }
  }

  /* ---------- Auto Sync Cycle ---------- */
  async function fullSync(){
   if(!navigator.onLine){updateBanner("Offline â€“ Local Only");return;}
   updateBanner("Online â€“ Syncingâ€¦");
   await syncUsersToCloud();await delay(1000);await syncUsersFromCloud();await fetchMaintenance();updateBanner("Online â€“ Synced");
  }
  window.addEventListener("online",fullSync);
  window.addEventListener("offline",()=>updateBanner("Offline â€“ Local Only"));
  setInterval(fullSync,60*1000);
  (async()=>{await fullSync();})();

  /* ---------- Realtime Subscriptions ---------- */
  supa.channel("users").on("postgres_changes",{event:"*",schema:"public",table:"users"},async(p)=>{
   if(!p.new?.email)return;
   const cur=await getCurrent();
   if(cur&&p.new.email===cur.email){await putLocalUser({...p.new,updatedAt:new Date(p.new.updated_at).getTime()});updateBanner("Realtime User Update");}
  }).subscribe();

  supa.channel("maintenance").on("postgres_changes",{event:"*",schema:"public",table:"maintenance"},async(p)=>{
   if(!p.new)return;
   await setMaint({enabled:p.new.active,message:p.new.message,manualUntil:p.new.end_time?new Date(p.new.end_time).getTime():null,updatedAt:p.new.updated_at?new Date(p.new.updated_at).getTime():Date.now()});
   await enforceMaintenance();
   updateBanner("Realtime Maintenance Update");
  }).subscribe();
  </script>
  <!-- === End Landing Sync Module === -->
</body>
</html>